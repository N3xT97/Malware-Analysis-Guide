```rust
extern crate winapi;  
  
use std::ffi::OsString;  
use std::os::windows::ffi::OsStringExt;  
use std::ptr::null_mut;  
use sysinfo::System;  
use winapi::shared::minwindef::DWORD;  
use winapi::um::winsvc::{  
    CloseServiceHandle, EnumServicesStatusW, OpenSCManagerW, ENUM_SERVICE_STATUSW,  
    SC_MANAGER_ENUMERATE_SERVICE,  
};  
  
fn cal_hash(s: &str) -> u32 {  
    let mut hash = 0u32;  
    let mut s_iter = s.chars();  
    loop {  
        let mut b = 0;  
        if let Some(c) = s_iter.next() {  
            b = c as u32;  
        }        let mut tmp = b;  
        if 0x40 < b && b < 0x5b {  
            tmp = b | 0x20;  
        }        hash = (hash >> 0xd | hash << 0x13) + tmp;  
        if b == 0 {  
            break;  
        }    
    }
    hash  
}  
  
fn main() {  
    println!("\n[*] Print Process Name Hash Table");  
    println!("{:^30} => {:^10} ({})",  "PROCESS", "HASH", "PID");  
    println!("{}", "=".repeat(70));  
    let process_hash_info_table = get_process_hash_info_table();  
    for process_hash_info in process_hash_info_table {  
        println!(  
            "{:<30} => {:#010x} ({})",  
             process_hash_info.process_name, process_hash_info.hash,process_hash_info.pid  
        );  
    }  
    println!("\n[*] Print Service Name Hash Table");  
    println!(  
        "{:^50} => {:^10} ({})",  
        "SERVICE", "HASH", "DISPLAY"  
    );  
    println!("{}", "=".repeat(100));  
    let service_hash_info_table;  
    service_hash_info_table = get_service_hash_info_hash_table();  
    for service_hash_info in service_hash_info_table {  
        println!(  
            "{:<50} => {:#010x} ({})",  
            service_hash_info.service_name, service_hash_info.hash, service_hash_info.display_name  
        );  
    }
}  
  
struct ProcessHashInfo {  
    pid: u32,  
    process_name: String,  
    hash: u32,  
}  
  
fn get_process_hash_info_table() -> Vec<ProcessHashInfo> {  
    let mut sys = System::new_all();  
    sys.refresh_all();  
    let mut process_hash_info_table: Vec<ProcessHashInfo> = Vec::new();  
    for (pid, process) in sys.processes() {  
        let process_name = process.name();  
        let hash = cal_hash(process_name);  
        process_hash_info_table.push(ProcessHashInfo {  
            pid: pid.as_u32(),  
            process_name: process_name.to_string(),  
            hash,  
        });
	}
	process_hash_info_table.sort_by(|a, b| a.process_name.cmp(&b.process_name));  
    process_hash_info_table  
}  
  
struct ServiceHashInfo {  
    display_name: String,  
    service_name: String,  
    hash: u32,  
}  
  
fn get_service_hash_info_hash_table() -> Vec<ServiceHashInfo> {  
    let mut service_hash_info_table: Vec<ServiceHashInfo> = Vec::new();  
    unsafe {  
        let scm = OpenSCManagerW(null_mut(), null_mut(), SC_MANAGER_ENUMERATE_SERVICE);  
  
        let mut bytes_needed: DWORD = 0;  
        let mut services_returned: DWORD = 0;  
        let mut resume_handle: DWORD = 0;  
        EnumServicesStatusW(  
            scm,  
            0x30,  
            3,  
            null_mut(),  
            0,  
            &mut bytes_needed,  
            &mut services_returned,  
            &mut resume_handle,  
        );  
        let mut buffer = vec![0u8; bytes_needed as usize];  
        let buffer_ptr = buffer.as_mut_ptr() as *mut ENUM_SERVICE_STATUSW;  
        EnumServicesStatusW(  
            scm,  
            0x30,  
            3,  
            buffer_ptr,  
            bytes_needed,  
            &mut bytes_needed,  
            &mut services_returned,  
            &mut resume_handle,  
        );        CloseServiceHandle(scm);  
  
        let mut i = 0;  
        while i < services_returned as usize {  
            let service_name =  
                lpwstr_to_string(buffer_ptr.wrapping_add(i).as_ref().unwrap().lpServiceName);  
            let display_name =  
                lpwstr_to_string(buffer_ptr.wrapping_add(i).as_ref().unwrap().lpDisplayName);  
            let hash = cal_hash(&service_name);  
            service_hash_info_table.push(ServiceHashInfo {  
                display_name,  
                service_name,  
                hash,  
            });
            i += 1;  
        }
	}
	service_hash_info_table.sort_by(|a, b| a.service_name.cmp(&b.service_name));  
    service_hash_info_table  
}  
  
unsafe fn lpwstr_to_string(str_ptr: *const u16) -> String {  
    let str_len = (0..).take_while(|&i| *str_ptr.offset(i) != 0).count();  
    let str = OsString::from_wide(std::slice::from_raw_parts(str_ptr, str_len))  
        .to_string_lossy()  
        .into_owned();
    str  
}
```

```toml
[package]  
name = "system_name_hash"  
version = "0.1.0"  
edition = "2021"  
  
[dependencies]  
sysinfo = "0.30.12"  
winapi = { version = "0.3.9", features = ["std", "winsvc", "minwindef"] }
```