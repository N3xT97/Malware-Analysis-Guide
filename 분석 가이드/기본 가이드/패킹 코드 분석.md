## 패킹된 바이너리의 실행

패킹된 바이너리가 실행되는 일반적인 단계

1. 메모리 할당
2. 페이로드 압축 해제
3. 임포트 테이블 복구
4. OEP로 이동
5. 페이로드 실행

패킹된 바이너리에서 자주 사용되는 NT API와 Win32 API

| NTDLL API               | Win32 API      |
| ----------------------- | -------------- |
| LdrLoadDll              | LoadLibrary    |
| LdrGetProcedureAddress  | GetProcAddress |
| NtAllocateVirtualMemory | VirtualAlloc   |
| NtProtectVirtualMemory  | VirtualProtect |
| NtFreeVirtualMemory     | VirtualFree    |
| NtWriteFile             | WriteFile      |
| NtReadFile              | ReadFile       |

### 1. 메모리 할당

로더는 언패킹된 페이로드를 저장할 메모리를 할당함. VirtualAlloc, HeapAlloc, GlobalAlloc, RtlAllocateHeap, NtAllocateVirtualMemory와 같은 API를 사용함. 로더는 해당 API를 여러번 호출하여 코드 및 데이터를 메모리 상에 배치.

일부 로더는 패커는 샘플의 기존 메모리 공간을 덮어쓰는 경우도 존재. 이런 경우 메모리 할당 API의 호출이 적거나 없을 수도 있음.

#### NtAllocateVirtualMemory와 NtProtectVirtualMemory를 사용해 메모리를 할당하는 API 로그
![[images/패킹 코드 분석/IMG-패킹 코드 분석-20240818160206330.png|582]]

### 2. 페이로드 압축 해제

로더는 할당ㅎ란 메모리 영역에 압축된 페이로드를 압축 해제 알고리즘을 사용해 언패킹. 사용되는 알고리즘은 다양하며 많은 수학적 연산을 수행하며 Win32 API 대신 원시 어샘블리 코드만을 사용하는 경우가 일반적.

일부 패커는 RtlDecompressBuffer API를 사용하여 압축을 해제하기도 함.

![[images/패킹 코드 분석/IMG-패킹 코드 분석-20240818160206421.png|642]]

### 3. 임포트 테이블 복구

로더는 언패킹된 페이로드의 임포트 테이블을 읽어 페이로드가 의존하는 API를 찾아냄. LoadLibrary 또는 LdrLoadDll를 사용하여 필요한 Dll을 로드하고, GetProcAddress 또는 LdrGetProcedureAddress를 사용해 필요한 API의 주소를 획득함.

![[images/패킹 코드 분석/IMG-패킹 코드 분석-20240818160209360.png|642]]

### 4. OEP로 이동

OEP는 로더가 언패킹된 페이로드로 실행을 전달할 때 첫 번째로 실행돼야 하는 명령의 주소. 페커는 일반적으로는 JMP나 CALL 명령어를 사용하여 제어를 넘기는데, OEP까지 도달하는데 여러 단계의 압축 해제가 필요할 수 있기 때문에 OEP에 도달했는지 확인하기 위해서는 추가적인 확인이 필요함.

### 5. 페이로드 실행

제어권이 OEP에 도착해 페이로드에 있는지 확인하기 위한 API 유형

- 디스크에 새 파일 생성
- 파일에 쓰기
- 레지스트리 키 및 값 생성
- 네트워크 연결
- 새로운 프로세스 생성
- 원격 프로세스 열기 및 쓰기
- 원격 프로세스에서 스레드 생성

#### RegCreateKeyExA API 같은 경우, 로더에서 호출되기 보다는 언패킹된 페이로드에서 호출되는 것이 일반적임.
![[images/패킹 코드 분석/IMG-패킹 코드 분석-20240818160209422.png|642]]

## 디버거를 사용한 수동 언패킹

수동 언패킹 단계

1. 메모리에서 압축 해제 또는 언패킹된 페이로드의 위치 파악
2. 페이로드를 디스크에 덤프

### 1. 페이로드의 위치 파악

RegCreateKeyExA를 호출하는 페이로드 코드 이전에 호출되는 Win32 API인 LdrGetProcedureAddress를 확인 가능함. 해당 LdrGetProcedureAddress API의 호출이 임포트 테이블 복구 단계라고 가정 가능. 그렇다면 LdrGetProcdureAddress와 RegCreateKeyExA에 OEP로 JMP할 가능성이 존재함.

#### API 로그에서 확인 가능한 LdrGetProcedureAddress 함수
![[images/패킹 코드 분석/IMG-패킹 코드 분석-20240818160212759.png|531]]

디버거를 실행시켜 LdrGetProcedureAddress에 중단점을 찍고, 매개변수가 CryptReleaseContext가 전달될 때까지 실행. RegCreateKeyExA가 실행되기까지 총 2번의 CryptReleaseContext를 파라미터로 가지는LdrGetProcedureAddress는 총 2번 실행되므로 2번째 호출까지 디버깅을 진행.

```
strstr(ansi([[esp+0x10]]), "CryptReleaseContext")
```

#### LdrGetProcedureAddress에 CryptReleaseContext가 전달되는 순간을 찾기 위한 Conditional BP를 설정
![[images/패킹 코드 분석/IMG-패킹 코드 분석-20240818160212816.png|642]]

LdrGetProcedureAddress 함수에 BP가 걸린 후 디버깅을 진행하면, 해당 API를 호출한 함수가 CryptReleaseContext라는 것을 알 수 있음. 이번에는 RegCreateKeyExA에 BP를 걸고 디버깅을 진행.

#### LdrGetProcedureAddress 함수를 호출한 주소 확인
![[images/패킹 코드 분석/IMG-패킹 코드 분석-20240818160215256.png|642]]

RegCreateExA에 BP가 걸린 후 디버깅을 진행하면, 해당 API를 호출한 함수를 확인할 수 있음.

#### RegCreateKeyExA 함수를 호출한 주소 확인
![[images/패킹 코드 분석/IMG-패킹 코드 분석-20240818160215319.png|642]]

Memory Map을 확인해보면 두 주소는 같은 128000 메모리 블록에서 실행된 것을 알 수 있음. 이것은 두 함수 모두 언패킹된 페이로드에서 실행되었거나 아직 페킹 단계일 수도 있다는 뜻. 해당 메모리 블록의 시작부분을 체크해보면 PE 포맷을 가지고 있는 것을 확인할 수 있음. 즉, 128000 메모리 블록은 언패킹된 페이로드임을 의미함.

#### 1280000의 속성을 확인해보면 ERW이고 Private 메모리임을 확인 가능 
![[images/패킹 코드 분석/IMG-패킹 코드 분석-20240818160217059.png|642]]

#### 1280000 주소의 메모리를 확인해보면 PE 구조를 가지고 있음 -> 언패킹 페이로드일 확률이 높음
![[images/패킹 코드 분석/IMG-패킹 코드 분석-20240818160218386.png|640]]

#### 내부 문자열을 확인해보면 의심스러운 문자열을 확인 가능
![[images/패킹 코드 분석/IMG-패킹 코드 분석-20240818160218449.png|642]]

### 2. 페이로드를 디스크에 덤프

언패킹된 페이로드를 찾았지만, 정확한 OEP의 위치는 아직 모름. OllyDumpEx의 Search 기능을 활용하면 이미지 상의 OEP를 알려줌. PE가 많이 훼손된 상태라면 정확한 OEP가 아닐 수도 있음. 그럴 경우 추가적인 분석을 통해 정확한 OEP를 찾아야 함. Section에서 잘못 선택된 섹션은 선택 해제 해줘야 함.

#### OllyDumpEx 플러그인을 사용해 메모리를 덤프
![[images/패킹 코드 분석/IMG-패킹 코드 분석-20240818160219728.png|483]]

#### 언패킹된 페이로드 덤프에 성공한 모습
![[images/패킹 코드 분석/IMG-패킹 코드 분석-20240818160219799.png|225]]

정확한 OEP를 확인하기 위해서는 덤프한 PE를 IDA, Ghidra와 같은 정적 분석 도구로 내부 코드를 확인해보거나 동적 디버깅을 통해 코드를 하나하나 확인해봐야 함. 멀웨어 중에서는 임포트 테이블이나 PE 구조를 심하게 훼손하는 경우도 존재하므로 덤프된 pe가 무조건 실행되리라는 보장은 없음.

예를 들어 NtAllocateVirtualMemory를 사용해 언패킹 코드를 저장할 0x20000 사이즈의 가상 메모리를 할당받는 코드에 BP를 설치. 해당 코드는 언패킹 페이로드를 저장할 메모리를 할당받는 코드일 확률이 높음. 해당 부분부터 이후 코드를 살펴볼 것임.

#### RegCreateKeyExA 이전에 호출되는 NtAllocateVirtualMemory
![[images/패킹 코드 분석/IMG-패킹 코드 분석-20240818160221022.png|642]]

#### NtAllocateVirtualMemory에 조건부 BP를 설치
![[images/패킹 코드 분석/IMG-패킹 코드 분석-20240818160221075.png|531]]

BP가 걸린 후, 디버깅을 해나가다보면 언패킹하는 부분을 확인할 수 있음. 그후에 할당한 VM으로 이동하는 코드가 존재하는데 반환 주소를 조작하는 방식을 이용함.

#### 언패킹 코드와 VM으로 이동하는 코드 확인 가능
![[images/패킹 코드 분석/IMG-패킹 코드 분석-20240818160222167.png|439]]

#### 반환 주소를 조작하는 방식을 사용
![[images/패킹 코드 분석/IMG-패킹 코드 분석-20240818160223184.png|584]]

언패킹된 코드 블록으로 이동한 후에는 특정 함수 내부로 이동하는데 EP처럼 보이지 않으므로 좀 더 진행하다보면 OEP처럼 보이는 코드가 보임. OEP로 추정되는 위치에 EIP를 위치시키고 OllyDumpEx의 Get EIP as OEP 기능을 사용해 Dump를 뜨면 됨.

#### OEP로 추정되는 코드
![[images/패킹 코드 분석/IMG-패킹 코드 분석-20240818160223947.png|483]]

#### OllyDumpEx의 Get EIP as OEP 기능을 사용
![[images/패킹 코드 분석/IMG-패킹 코드 분석-20240818160224007.png|439]]