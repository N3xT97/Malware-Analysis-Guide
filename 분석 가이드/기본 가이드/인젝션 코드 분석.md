## IEP, Injection Entry Point

악성 코드는 은폐를 포함한 다양한 이유로 특정 프로세스에 코드를 주입함. 

대상 프로세스에 악성 코드를 삽입한 후 인젝터는 대상 프로세스의 내부에서 삽입된 코드를 실행해야 함. 이때 삽입된 코드의 첫 바이트부터 실행 가능한 코드가 있을 필요는 없음. 주입된 코드가 Dll인 경우, 첫 번째 바이트는 PE 헤더로 시작하고 실행 코드는 Dll 내부 어딘가에 존재.

인젝터가 결정하는 대상 프로세스의 삽입된 코드 내부에서 실행을 시작하는 주소를 IEP라고 함. 일반적으로 IEP는 인젝터에서 결정되므로 인젝터를 디버깅하면 IEP 단서를 얻을 수 있음.

## CreateRemoteThread를 활용한 인젝션된 코드의 실행

CreateRemoteThread를 활용한 인젝션 코드의 일반적인 실행 단계

1. CreateToolhelp32Snapshot 등의 API를 활용하여 대상 프로세스를 찾음.
2. NtOpenProcess 등의 API로 대상 프로세스의 핸들을 찾음.
3. NtAllocateVirtualMemory 등의 API로 대상 프로세스 내에 메모리를 할당.
4. WriteProcessMemory 등의 API로 대상 프로세스 내에 인젝션 코드를 복사.
5. CreateRemoteThread를 호출하여 대상 프로세스 내의 인젝션 코드를 원격으로 실행.


악성코드는 가장 먼저 CreateToolhelp32Snapshot, Process32FirstW, Process32NextW API들을 사용하여 코드가 삽입될 프로세스를 찾음.

#### 대상 프로세스를 찾는 API 로그
![584](images/인젝션%20코드%20분석/IMG-인젝션%20코드%20분석-20240818160206328.png)

대상 프로세스를 발견했다면, 해당 프로세스의 핸들을 획득하고 해당 프로세스 내에 VM을 생성한 후 인젝션 코드를 작성. 작성이 완료되었다면 CreateRemoteThread를 호출하여 인젝션된 코드를 실행.

#### 코드를 인젝션하고 실행하는 API 로그
![584](images/인젝션%20코드%20분석/IMG-인젝션%20코드%20분석-20240818160206419.png)

## CreateRemoteThread를 활용한 인젝션 코드 디버깅

CreateRemoteThread를 활용한 인젝션 코드 디버깅 단계

1. 대상 프로세스의 PID 확인
2. 대상 프로세스에 메모리를 할당하는 코드 확인
3. 할당된 메모리에 인젝션 코드를 작성하는 코드 확인
4. CreateRemoteThread API에서 IEP 획득
5. 대상 프로세스에 디버거 attach

### 1. 대상 프로세스의 PID와 Handle을 확인

NtOpenProcess에 중단점을 설정하여 대상 프로세스의 PID와 Handle을 확인. 예시에서 PID는 0xADC(2780), Process Handle은 0x9C 임.

#### NtOpenProcess에 BP를 걸고 PID를 확인
![642](images/인젝션%20코드%20분석/IMG-인젝션%20코드%20분석-20240818160209078.png)

#### OpenProcess 실행 후에 획득한 Process Handle 확인
![642](images/인젝션%20코드%20분석/IMG-인젝션%20코드%20분석-20240818160209138.png)

### 2. 대상 프로세스에 메모리를 할당하는 코드 확인

인젝터 프로세스는 획득한 Process Handle을 사용하여 대상 프로세스 내에 메모리를 할당함. NtAllocateVirtualMemory에 대상 프로세스의 Process Handle을 전달하는 코드를 찾기 위해 조건부 BP를 설정하여 할당하는 메모리 주소를 획득. 예시에서는 0x320000 주소에 메모리를 할당.

#### NtAllocateVirtualMemory에 조건부 BP 설정
![584](images/인젝션%20코드%20분석/IMG-인젝션%20코드%20분석-20240818160212598.png)

#### VirtualAllocEx를 실행한 결과
![584](images/인젝션%20코드%20분석/IMG-인젝션%20코드%20분석-20240818160215017.png)

### 3. 할당된 메모리에 인젝션 코드를 작성하는 코드 확인

VirtualAlloc 아래쪽에 WriteProcessMemory API가 존재하는데 해당 API에 전달되는 인수들을 확인하면 인젝션되는 코드를 확인할 수 있음. 코드가 인젝션 되면 ProcessHacker 도구를 사용하여 대상 프로세스 내에 인젝션된 데이터를 확인 가능.

#### WriteProcessMemory에 전달되는 인수에서 인젝션되는 코드 확인
![642](images/인젝션%20코드%20분석/IMG-인젝션%20코드%20분석-20240818160215079.png)

#### 디스어셈블된 인젝션 코드 내용
![529](images/인젝션%20코드%20분석/IMG-인젝션%20코드%20분석-20240818160216761.png)

#### ProcessHacker를 통해 확인된 프로세스 내의 인젠션된 데이터
![531](images/인젝션%20코드%20분석/IMG-인젝션%20코드%20분석-20240818160216819.png)

### 4. CreateRemoteThread API에서 IEP 획득

CreateRemoteThread에는 StartAddress라는 원격 스레드가 실행을 시작해야되는 주소가 전달됨. 

#### CreateRemoteThread에 전달되는 StartAddress를 획득
![584](images/인젝션%20코드%20분석/IMG-인젝션%20코드%20분석-20240818160218153.png)

### 5. 대상 프로세스에 디버거 attach

디버거를 열어 대상 프로세스의 PID를 찾고 attach. StartAddress를 찾아 BP를 설치하고 run을 눌러 대상 프로세스를 실행시킴. 대상 프로세스를 run 시킨 후에는 인젝터로 다시 돌아와서 CreateRemoteThread를 실행시킴.

#### 대상 프로세스의 PID를 찾음
![363](images/인젝션%20코드%20분석/IMG-인젝션%20코드%20분석-20240818160218217.png)

#### StartAddress에 BP 설치
![531](images/인젝션%20코드%20분석/IMG-인젝션%20코드%20분석-20240818160219560.png)

#### 대상 프로세스의 StartAddress에서 BP가 걸린 것을 확인 가능
![531](images/인젝션%20코드%20분석/IMG-인젝션%20코드%20분석-20240818160220795.png)

가끔 프로세스 할로잉에서 아직 프로세스가 일시 중단 상태일 때는 디버거가 해당 프로세스에 attach하지 못할 수도 있음. 이런 경우 StartAddress의 시작 코드를 0xEBFE로 변경하는 기법을 시도해야 함.

## Thread Context를 활용한 인젝션 코드의 실행

멀웨어가 대상 프로세스에서 코드를 실행하는 데 사용하는 또 다른 방법은 대상 프로세스에서 원격 스레드의 콘텍스트를 변경하는 것. 스레드 콘텍스트 내에는 레지스터의 상태, 프로세스이 메인 모듈의 진입점 등과 같은 다양한 정보를 저장할 수 있는 구조체. 스레드 컨텍스트를 변경하려면, 작업 스케줄러가 하당 콘텍스트를 변경하지 않도록 스레드가 일시 중지 상태에 있어야 함.

Thread Context를 활용한 인젝션 코드의 일반적인 실행 단계

1. 대상 프로세스를 suspend 상태로 실행
2. 인젝터는 GetThreadContext를 사용해 대상 프로세스 스레드의 콘텍스트 구조 복사본을 검색
3. 다음 콘텍스트 구조체의 로컬 복사본을 대상으로 프로세스에서 삽입된 코드의 위치에 따라 변경
4. 콘텍스트 구조의 변경된 로컬 복사본은 SetThreadContext API를 사용해 대상 프로세스로 다시 복사
5. 자신을 종료

#### Thread Context를 활용한 인젝션의 API 로그 API 로그
![642](images/인젝션%20코드%20분석/IMG-인젝션%20코드%20분석-20240818160220863.png)


## Thread Context를 활용한 인젝션 코드 디버깅

Thread Context를 활용한 인젝션 코드 디버깅 단계

1. CreateProcessInternalW API에 전달된 인수를 확인하여 대상 프로세스의 정보를 확인
2. SetThreadContext API에서 ThreadContext 데이터를 확인

### 1. CreateProcessInternalW API에 전달된 인수를 확인하여 대상 프로세스의 정보를 확인

CreateProcessInternalW에는 대상 프로세스의 위치와 PROCESS_INFORMATION 구조체 주소가 전달됨. PROCESS_INFORMATION 구조체 내부에서 대상 프로세스의 PID 정보를 획득할 수 있음. 

#### CreateProcessInternalW에 전달되는 대상 프로세스 정보 확인
![642](images/인젝션%20코드%20분석/IMG-인젝션%20코드%20분석-20240818160221795.png)

CreateProcessInternalW를 실행하게 되면 대상 프로세스가 SUSPEND로 실행되면서 전달된 PROCESS_INFORMATION가 채워지게 되고, 대상 프로세스의 Thread Handle과 PID를 확인할 수 있음. 

#### 확인된 대상 프로세스의 정보
![439](images/인젝션%20코드%20분석/IMG-인젝션%20코드%20분석-20240818160221854.png)

### 2. SetThreadContext API에서 ThreadContext 데이터를 확인

악성코드는 SUSPEND된 Thread를 Resume하기 전에, SetThreadContext를 사용하여 대상 프로세스에 변경된 ThreadContext를 설정함. 해당 ThreadContext 내에 EAX, EIP 필드에 IEP가 설정되어 있음.

#### CONTEXT 내의 EAX(0xb0)와 EIP(0xb8) 확인
![531](images/인젝션%20코드%20분석/IMG-인젝션%20코드%20분석-20240818160222980.png)

### 3. 대상 프로세스에 디버거 attach

대상 프로세스에 디버거를 attach하고 IEP에 중단점을 설정 후, 인젝터에서 ResumeThread를 호출하면 대상 프로세스의 EIP부터 디버깅 가능.

#### 대상 프로세스에 디버거를 attach하고 EIP에 중단점 설정
![483](images/인젝션%20코드%20분석/IMG-인젝션%20코드%20분석-20240818160223047.png)


## EBFE 기법

대상 프로세스에서 EIP가 실행되기 전에, ProcessHacker를 사용하여 첫 번째 2바이트를 기록한 후, EBFE로 변경.

#### 대상 프로세스의 IEP 첫 번째 2바이트를 EBFE로 변경 후 Write 버튼 클릭
![531](images/인젝션%20코드%20분석/IMG-인젝션%20코드%20분석-20240818160223763.png)

EBFE로 변경 후, 인젝터 프로세스에서 Thread를 실행하게 되면 대상 프로세스에서는 IEP에서 무한 루프가 걸려 있는 상태가 됨. 디버거를 실행하여 실행 중인 대상 프로세스에 attach한 후 일시정지를 루프 무한 루프 걸린 부분에 멈추게 됨. 다시 코드를 원본 바이트인 FC33으로 패치 후 디버깅.

#### IEP의 시작 분에서 무한루프가 걸린 대상 프로세스
![531](images/인젝션%20코드%20분석/IMG-인젝션%20코드%20분석-20240818160223827.png)

#### 원본 바이트로 패치된 IEP
![531](images/인젝션%20코드%20분석/IMG-인젝션%20코드%20분석-20240818160224365.png)