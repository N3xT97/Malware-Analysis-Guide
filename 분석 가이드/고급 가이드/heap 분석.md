## Windbg Heap Command List

[**Windbg Heap Command List***](http://windbg.info/doc/1-common-cmds.html#20_memory_heap)

## Heap 관련 정보

1. ProcessHeaps 필드나 !heap 명령어를 통해 획득한 heap addr은 GetProcessHeap, CreateHeap 등을 통해 획득한 heap handle의 주소라 봐도 됨.
2. heapalloc 등을 통해 메모리를 할당하면 \_HEAP\_ENTRY 구조체를 헤더로 가지는 메모리 블록이 생성됨.
3. 우리는 헤더 부분 다음의 가용한 메모리 부분의 주소를 반환받아 사용함.
4. 해당 메모리 블록은 \_HEAP 구조체의 FirstEntry에 삽입됨.
5. 하지만 \_HEAP 구조체 내에는 NextEntry를 찾을 수가 없는데, \_HEAP_ENTRY를 사용하여 직접 블록의 크기를 계산하여 NextEntry를 찾을 수 있음.
6. 이때 \_HEAP\_ENTRY 구조체 내부를 확인하기 위해서는 \_HEAP 구조체의 Encoding 값을 사용하여 XOR 복호화를 해줘야 함.

## 쓸만한 heap 관련 명령어

- `!heap`: all heaps list
	
	![330](images/heap%20분석/IMG-heap%20분석-20240818160206320.png)
	
- `!heap -s`: all heaps summary info table
	
	![584](images/heap%20분석/IMG-heap%20분석-20240818160206413.png)
	
- `!heap -h`: all heaps range and index list
	
	![399](images/heap%20분석/IMG-heap%20분석-20240818160207646.png)
	
- `!heap -h [HeapAddr | Idx | 0]`: heap detail info \[Idx = heap Idx, 0 = all heaps\]
	
	![503](images/heap%20분석/IMG-heap%20분석-20240818160207744.png)
	

## heap 관련 명령어를 사용하여 \_HEAP 구조체 확인

1. `!heap` 명령어를 사용하여 heap 주소 획득
	
	![330](images/heap%20분석/IMG-heap%20분석-20240818160206320.png)
	
2. `dt ntdll!_HEAP [heap addr]` 명령어를 사용하여 \_HEAP 구조체 확인
	
	![389](images/heap%20분석/IMG-heap%20분석-20240818160210387.png)
	

## PEB를 통해 \_HEAP 구조체 확인

1. `0:005> dt _PEB @$peb`를 사용해 PEB의 `NumberOfHeaps (+0x088)`, `ProcessHeaps (0x090)` 필드 확인
	
	![399](images/heap%20분석/IMG-heap%20분석-20240818160210458.png)
	![399](images/heap%20분석/IMG-heap%20분석-20240818160213263.png)
2. ProcessHeaps를 확인하면 heap 주소를 획득할 수 있음.
	
	![300](images/heap%20분석/IMG-heap%20분석-20240818160213323.png)
	
3. `dt ntdll!_HEAP [heap addr]` 명령어를 사용하여 \_HEAP 구조체 확인.
	
	![439](images/heap%20분석/IMG-heap%20분석-20240818160215487.png)
	

## \_HEAP\_ENTRY 구조체 확인

1. FirstEntry를 확인하여 첫 번째 메모리 블록의 \_HEAP\_ENTRY 주소 확인
	
	![399](images/heap%20분석/IMG-heap%20분석-20240818160217245.png)
	
2. \_HEAP\_ENTRY 구조체와 \_HEAP 구조체의 Encoding (0x50) 필드 확인
	
	![248](images/heap%20분석/IMG-heap%20분석-20240818160217301.png)
	
	![273](images/heap%20분석/IMG-heap%20분석-20240818160218513.png)
	
3. 두 값을 xor 연산
	
	![399](images/heap%20분석/IMG-heap%20분석-20240818160218578.png)
	
4. 비어있는 메모리를 찾아 해당 값을 복사
	
	![330](images/heap%20분석/IMG-heap%20분석-20240818160219880.png)
	
	![300](images/heap%20분석/IMG-heap%20분석-20240818160219961.png)
	
5. 복사한 값을 \_HEAP_ENTRY 구조체로 덤프하여 확인
	
	![334](images/heap%20분석/IMG-heap%20분석-20240818160221196.png)
	

## \_HEAP_ENTRY를 사용하여 다음 메모리 블록 주소 계산

1. \_HEAP_ENTRY가 단위 크기인 Size와 PreviousSize를 사용
	- Size: 현재 블록의 단위 크기
	- PreviousSize를: 이전 블록의 단위 크기
	
	![338](images/heap%20분석/IMG-heap%20분석-20240818160222244.png)
	
2. 이전 블록의 주소와 다음 블록의 주소 계산
	- \_HEAP_ENTRY의 크기
		
		![205](images/heap%20분석/IMG-heap%20분석-20240818160223253.png)
		
	- 이전 블록의 주소 = 현재 블록의 주소 - 이전 블록의 단위 크기 \* `sizeof(\_HEAP_ENTRY)`
		
		![127](images/heap%20분석/IMG-heap%20분석-20240818160223318.png)
		
	- 다음 블록의 주소 = 현재 블록의 주소 + 현재 블록의 단위 크기 \* `sizeof(\_HEAP_ENTRY)`
		
		![127](images/heap%20분석/IMG-heap%20분석-20240818160224087.png)
		
	- !heap -h 0x920000 명령어로 확인
		
		![330](images/heap%20분석/IMG-heap%20분석-20240818160224159.png)
		