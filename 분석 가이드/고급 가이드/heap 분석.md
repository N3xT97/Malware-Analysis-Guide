## Windbg Heap Command List

[**Windbg Heap Command List***](http://windbg.info/doc/1-common-cmds.html#20_memory_heap)

## Heap 관련 정보

1. ProcessHeaps 필드나 !heap 명령어를 통해 획득한 heap addr은 GetProcessHeap, CreateHeap 등을 통해 획득한 heap handle의 주소라 봐도 됨.
2. heapalloc 등을 통해 메모리를 할당하면 \_HEAP\_ENTRY 구조체를 헤더로 가지는 메모리 블록이 생성됨.
3. 우리는 헤더 부분 다음의 가용한 메모리 부분의 주소를 반환받아 사용함.
4. 해당 메모리 블록은 \_HEAP 구조체의 FirstEntry에 삽입됨.
5. 하지만 \_HEAP 구조체 내에는 NextEntry를 찾을 수가 없는데, \_HEAP_ENTRY를 사용하여 직접 블록의 크기를 계산하여 NextEntry를 찾을 수 있음.
6. 이때 \_HEAP\_ENTRY 구조체 내부를 확인하기 위해서는 \_HEAP 구조체의 Encoding 값을 사용하여 XOR 복호화를 해줘야 함.

## 쓸만한 heap 관련 명령어

- `!heap`: all heaps list
	
	![[images/heap 분석/IMG-heap 분석-20240818160206320.png|330]]
	
- `!heap -s`: all heaps summary info table
	
	![[images/heap 분석/IMG-heap 분석-20240818160206413.png|584]]
	
- `!heap -h`: all heaps range and index list
	
	![[images/heap 분석/IMG-heap 분석-20240818160207646.png|399]]
	
- `!heap -h [HeapAddr | Idx | 0]`: heap detail info \[Idx = heap Idx, 0 = all heaps\]
	
	![[images/heap 분석/IMG-heap 분석-20240818160207744.png|503]]
	

## heap 관련 명령어를 사용하여 \_HEAP 구조체 확인

1. `!heap` 명령어를 사용하여 heap 주소 획득
	
	![[images/heap 분석/IMG-heap 분석-20240818160206320.png|330]]
	
2. `dt ntdll!_HEAP [heap addr]` 명령어를 사용하여 \_HEAP 구조체 확인
	
	![[images/heap 분석/IMG-heap 분석-20240818160210387.png|389]]
	

## PEB를 통해 \_HEAP 구조체 확인

1. `0:005> dt _PEB @$peb`를 사용해 PEB의 `NumberOfHeaps (+0x088)`, `ProcessHeaps (0x090)` 필드 확인
	
	![[images/heap 분석/IMG-heap 분석-20240818160210458.png|399]]
	![[images/heap 분석/IMG-heap 분석-20240818160213263.png|399]]
2. ProcessHeaps를 확인하면 heap 주소를 획득할 수 있음.
	
	![[images/heap 분석/IMG-heap 분석-20240818160213323.png|300]]
	
3. `dt ntdll!_HEAP [heap addr]` 명령어를 사용하여 \_HEAP 구조체 확인.
	
	![[images/heap 분석/IMG-heap 분석-20240818160215487.png|439]]
	

## \_HEAP\_ENTRY 구조체 확인

1. FirstEntry를 확인하여 첫 번째 메모리 블록의 \_HEAP\_ENTRY 주소 확인
	
	![[images/heap 분석/IMG-heap 분석-20240818160217245.png|399]]
	
2. \_HEAP\_ENTRY 구조체와 \_HEAP 구조체의 Encoding (0x50) 필드 확인
	
	![[images/heap 분석/IMG-heap 분석-20240818160217301.png|248]]
	
	![[images/heap 분석/IMG-heap 분석-20240818160218513.png|273]]
	
3. 두 값을 xor 연산
	
	![[images/heap 분석/IMG-heap 분석-20240818160218578.png|399]]
	
4. 비어있는 메모리를 찾아 해당 값을 복사
	
	![[images/heap 분석/IMG-heap 분석-20240818160219880.png|330]]
	
	![[images/heap 분석/IMG-heap 분석-20240818160219961.png|300]]
	
5. 복사한 값을 \_HEAP_ENTRY 구조체로 덤프하여 확인
	
	![[images/heap 분석/IMG-heap 분석-20240818160221196.png|334]]
	

## \_HEAP_ENTRY를 사용하여 다음 메모리 블록 주소 계산

1. \_HEAP_ENTRY가 단위 크기인 Size와 PreviousSize를 사용
	- Size: 현재 블록의 단위 크기
	- PreviousSize를: 이전 블록의 단위 크기
	
	![[images/heap 분석/IMG-heap 분석-20240818160222244.png|338]]
	
2. 이전 블록의 주소와 다음 블록의 주소 계산
	- \_HEAP_ENTRY의 크기
		
		![[images/heap 분석/IMG-heap 분석-20240818160223253.png|205]]
		
	- 이전 블록의 주소 = 현재 블록의 주소 - 이전 블록의 단위 크기 \* `sizeof(\_HEAP_ENTRY)`
		
		![[images/heap 분석/IMG-heap 분석-20240818160223318.png|127]]
		
	- 다음 블록의 주소 = 현재 블록의 주소 + 현재 블록의 단위 크기 \* `sizeof(\_HEAP_ENTRY)`
		
		![[images/heap 분석/IMG-heap 분석-20240818160224087.png|127]]
		
	- !heap -h 0x920000 명령어로 확인
		
		![[images/heap 분석/IMG-heap 분석-20240818160224159.png|330]]
		