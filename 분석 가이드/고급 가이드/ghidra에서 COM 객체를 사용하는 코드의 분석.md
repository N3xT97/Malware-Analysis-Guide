## CLID와 IID 분석

- COM 객체 사용을 위해서는 CoCreateInstance를 호출하고 CLSID, IID를 전달하고 Interface를 얻어옴
    ![[images/ghidra에서 COM 객체를 사용하는 코드의 분석/IMG-ghidra에서 COM 객체를 사용하는 코드의 분석-20240818160206321.png|IMG-ghidra에서 COM 객체를 사용하는 코드의 분석-20240818160206321.png]]
    
- CLSID와 IID를 Regedit에 검색하여 어떤 인터페이스를 사용하고자 하는지 확인 가능
    
    ![[images/ghidra에서 COM 객체를 사용하는 코드의 분석/IMG-ghidra에서 COM 객체를 사용하는 코드의 분석-20240818160206414.png|IMG-ghidra에서 COM 객체를 사용하는 코드의 분석-20240818160206414.png]]
    
    ![[images/ghidra에서 COM 객체를 사용하는 코드의 분석/IMG-ghidra에서 COM 객체를 사용하는 코드의 분석-20240818160208371.png|IMG-ghidra에서 COM 객체를 사용하는 코드의 분석-20240818160208371.png]]
    
- ghidra 사용 시, COM 객체를 사용하는 코드의 경우 완벽하게 디컴파일되지 않음.  
    CoCreateInstance를 통해 획득한 Interface는 함수의 배열이라고 생각해도 됨.  
    32bit 시스템 기준으로 함수의 주소는 4바이트이므로 0x28의 경우, Interface에서 11번째 함수를 나타냄.  
    
    ![[images/ghidra에서 COM 객체를 사용하는 코드의 분석/IMG-ghidra에서 COM 객체를 사용하는 코드의 분석-20240818160211939.png|IMG-ghidra에서 COM 객체를 사용하는 코드의 분석-20240818160211939.png]]
    


## TypeLib Key가 존재하는 경우

- 앞서 검색한 CLSID 레지스트리 키에는 TypeLib이라는 Key가 존재.  
    해당 키를 다시 Regedit에 검색하면 TypeLib를 알아낼 수 있음.  
    
    ![[images/ghidra에서 COM 객체를 사용하는 코드의 분석/IMG-ghidra에서 COM 객체를 사용하는 코드의 분석-20240818160214150.png|IMG-ghidra에서 COM 객체를 사용하는 코드의 분석-20240818160214150.png]]
    
    ![[images/ghidra에서 COM 객체를 사용하는 코드의 분석/IMG-ghidra에서 COM 객체를 사용하는 코드의 분석-20240818160214220.png|IMG-ghidra에서 COM 객체를 사용하는 코드의 분석-20240818160214220.png]]
    
- Window SDK에서 제공되는 oleview.exe를 사용하여 해당 TypeLib를 찾음
    
    `C:\Program Files (x86)\Windows Kits\10\bin\10.0.17763.0\x86\oleview.exe`
    
    ![[images/ghidra에서 COM 객체를 사용하는 코드의 분석/IMG-ghidra에서 COM 객체를 사용하는 코드의 분석-20240818160216066.png|IMG-ghidra에서 COM 객체를 사용하는 코드의 분석-20240818160216066.png]]
    
- 내부에서 원하는 interface의 구조를 확인할 수 있음.
    
    ![[images/ghidra에서 COM 객체를 사용하는 코드의 분석/IMG-ghidra에서 COM 객체를 사용하는 코드의 분석-20240818160217716.png|IMG-ghidra에서 COM 객체를 사용하는 코드의 분석-20240818160217716.png]]
    
- 해당 포스팅의 예시인 ITaskService의 11번째 함수를 찾기 위해서는 상속되어 있는 모든 함수를 살펴보아야 함.
    
    ![[images/ghidra에서 COM 객체를 사용하는 코드의 분석/IMG-ghidra에서 COM 객체를 사용하는 코드의 분석-20240818160219000.png|IMG-ghidra에서 COM 객체를 사용하는 코드의 분석-20240818160219000.png]]
    

## TypeLib Key가 존재하지 않는 경우

- Interface 명을 인터넷이 검색하면, 헤더 파일을 알 수 있음.
	
	![[images/ghidra에서 COM 객체를 사용하는 코드의 분석/IMG-ghidra에서 COM 객체를 사용하는 코드의 분석-20240818160220278.png|300]]
	
- Everything을 사용하여 해더 파일 검색
	
	![[images/ghidra에서 COM 객체를 사용하는 코드의 분석/IMG-ghidra에서 COM 객체를 사용하는 코드의 분석-20240818160220338.png|330]]
	
- 해당 헤더 파일을 열어 인터페이스 검색 가능
	
	![[images/ghidra에서 COM 객체를 사용하는 코드의 분석/IMG-ghidra에서 COM 객체를 사용하는 코드의 분석-20240818160221412.png|531]]
	
- C++과 C언어에서의 함수의 정의는 다름
	- 또한 해당 함수의 정의는 C++ 기준이므로 자기 자신을 전달하는 매개변수가 포함되어 있지 않음.
	+ C 언어 스타일에서는 this가 포함되므로 파라미터가 하나 더 추가된다고 생각해야 함.  
	
	![[images/ghidra에서 COM 객체를 사용하는 코드의 분석/IMG-ghidra에서 COM 객체를 사용하는 코드의 분석-20240818160222485.png|IMG-ghidra에서 COM 객체를 사용하는 코드의 분석-20240818160222485.png]]